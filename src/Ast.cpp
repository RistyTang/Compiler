#include "Ast.h"
#include "SymbolTable.h"
#include "Unit.h"
#include "Instruction.h"
#include "IRBuilder.h"
#include <string>
#include "Type.h"

extern FILE *yyout;
int Node::counter = 0;
IRBuilder* Node::builder = nullptr;

Node::Node()
{
    seq = counter++;
}

//设置多个节点
void Node::setnext(Node* node) 
{
    Node* n = this;
    while (n->getnext()) {
        n = n->getnext();
    }
    if (n == this) {
        this->next = node;
    } else {
        n->setnext(node);
    }
}

//回填实现
void Node::backPatch(std::vector<Instruction*> &list, BasicBlock*bb)
{
    //从当前指令列表依次遍历
    for(auto &inst:list)
    {
        //如果是条件跳转指令
        if(inst->isCond())
        {
            //将当前基本块的前驱设置为这条指令来自于的基本块
            bb->addPred(dynamic_cast<CondBrInstruction*>(inst)->getParent());
            //将当前基本块设置为此条件跳转指令所在基本块的后继
            dynamic_cast<CondBrInstruction*>(inst)->getParent()->addSucc(bb);
            //条件为真时的跳转
            dynamic_cast<CondBrInstruction*>(inst)->setTrueBranch(bb);
        }
        //如果是无条件跳转指令
        else if(inst->isUncond())
        {    
            //将当前基本块的前驱设置为这条指令来自于的基本块
            bb->addPred(dynamic_cast<CondBrInstruction*>(inst)->getParent());
            //将当前基本块设置为此条件跳转指令所在基本块的后继
            dynamic_cast<CondBrInstruction*>(inst)->getParent()->addSucc(bb);
            dynamic_cast<UncondBrInstruction*>(inst)->setBranch(bb);

        }
    }
}

std::vector<Instruction*> Node::merge(std::vector<Instruction*> &list1, std::vector<Instruction*> &list2)
{
    std::vector<Instruction*> res(list1);
    res.insert(res.end(), list2.begin(), list2.end());
    return res;
}

void ExprNode::typeCheck(Node* fromnode=nullptr)
{

}

void ExprNode::genCode()
{
    //无需增加代码
}

void ExprNode::output(int level) 
{
    std::string type, value;
    type = symbolEntry->getType()->toStr();
    value = symbolEntry->toStr();
    fprintf(yyout, "%*cconst string\tvalue: %s\ttype: %s\n", level, ' ',
            value.c_str(), type.c_str());
}

void BinaryExpr::genCode()
{
    //builder 是 IRBuilder 类对象，用于传递继承属性，辅助我们进行中间代码生成
    //通过 builder 得到后续生成的指令要插入的基本块 bb
    BasicBlock *bb = builder->getInsertBB();
    Function *func = bb->getParent();
    //生成子表达式的中间代码
    if (op == ANDAND)// &&
    {
        //第二个子表达式生成的指令需要插入的位置
        BasicBlock *trueBB = new BasicBlock(func); 
        //在当前基本块生成第一个子表达式的中间代码，
        expr1->genCode();
        //当expr1为真时，跳转目标为trueBB，因此truelist的回填目标是trueBB
        backPatch(expr1->trueList(), trueBB);
        //设置当前块为trueBB，即接下来生成的中间代码放入truebb块
        builder->setInsertBB(trueBB);               // set the insert point to the trueBB so that intructions generated by expr2 will be inserted into it.
        //trueBB开始的指令为expr2的中间代码
        expr2->genCode();
        //不能知道两个子表达式的 false_list 的跳转基本块，
        //便只能将其插入到当前结点的 false_list中，
        //让父结点回填当前结点的 true_list 和 false_list。
        true_list = expr2->trueList();
        false_list = merge(expr1->falseList(), expr2->falseList());
    }
    else if(op == OROR)// ||
    {
        // Todo ——————按照&&仿写
        //第二个子表达式生成的指令需要插入的位置
        BasicBlock *trueBB = new BasicBlock(func); 
        //在当前基本块生成第一个子表达式的中间代码，
        expr1->genCode();
        //当expr1为假时，依赖于expr2的结果，因此跳转目标为trueBB，因此truelist的回填目标是trueBB
        backPatch(expr1->falseList(), trueBB);
        //设置当前块为trueBB，即接下来生成的中间代码放入truebb块
        builder->setInsertBB(trueBB);               // set the insert point to the trueBB so that intructions generated by expr2 will be inserted into it.
        //trueBB开始的指令为expr2的中间代码
        expr2->genCode();
        //不能知道两个子表达式的 true_list 的跳转基本块，
        //便只能将其插入到当前结点的 true_list
        //让父结点回填当前结点的 true_list 和 false_list。
        true_list = merge(expr1->trueList(), expr2->trueList());
        false_list = expr2->falseList();
    }
    else if(op >= LESS && op <= GREATER)
    {
        //属于CmpInstruction
        // Todo
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch (op)
        {
        case LESS:
            opcode=CmpInstruction::L;
            break;
        case GEQUAL:
            opcode=CmpInstruction::GE;
            break;
        case LEQUAL:
            opcode=CmpInstruction::LE;
            break;
        case EQUAL:
            opcode=CmpInstruction::E;
            break;
        case NOTEQUAL:
            opcode=CmpInstruction::NE;
            break;
        case GREATER:
            opcode=CmpInstruction::G;
        default:
            break;
        }
        new CmpInstruction(opcode, dst, src1, src2, bb);
        //自行添加的正确错误列表合并
        true_list = merge(expr1->trueList(), expr2->trueList());
        false_list = merge(expr1->falseList(), expr2->falseList());
        //需要增加对之后指令插入位置的判别
        BasicBlock *truebb = new BasicBlock(func); 
        BasicBlock *falsebb = new BasicBlock(func); 
        BasicBlock *tempbb = new BasicBlock(func); 
        //为真和为假时对应不同的指令
        Instruction* temp1 = new CondBrInstruction(truebb,tempbb,dst,bb);
        Instruction* temp2 = new CondBrInstruction(falsebb,tempbb,dst,bb);
       true_list.push_back(temp1);
        false_list.push_back(temp2);
        //设置为bool类型
        dst -> getType() -> setKind(4);
    }
    else if(op >= ADD && op <= DIV)
    {
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch (op)
        {
        case ADD:
            opcode = BinaryInstruction::ADD;
            break;
        case SUB:
            opcode = BinaryInstruction::SUB;
            break;
        case MUL:
            opcode = BinaryInstruction::MUL;
            break;
        case DIV:
            opcode = BinaryInstruction::DIV;
            break;
        case MOD:
            opcode = BinaryInstruction::MOD;
            break;
        }
        new BinaryInstruction(opcode, dst, src1, src2, bb);
    }
}

void BinaryExpr::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "add";
            break;
        case SUB:
            op_str = "sub";
            break;
        case AND:
            op_str = "and";
            break;
        case OR:
            op_str = "or";
            break;
        case LESS:
            op_str = "less";
            break;
        case MUL:
            op_str = "mul";
            break;
        case DIV:
            op_str = "div";
            break;
        case GREATER:
            op_str = "greater";
            break;
        case EXCLA:
            op_str = "excla";//!
            break;
        case GEQUAL:
            op_str = "gequal";//>=
            break;
        case LEQUAL:
            op_str = "lequal";//<=
            break;
        case EQUAL:
            op_str = "equal";//==
            break;
        case NOTEQUAL:
            op_str = "notequal";
            break;//!=
        case MOD:
            op_str = "mod";
            break;
        case MLEFT:
            op_str = "mleft";//左移
            break;
        case MRIGHT:
            op_str="mright";//右移
            break;
        case ANDAND:
            op_str="andand";//&&
            break;
        case OROR:
            op_str="oror";//||
            break;
        case ASSIGN:
            op_str="assign";//=
            break;
        case ASSIGNADD:
            op_str="assignadd";//+=
            break;
        case ASSIGNSUB:
            op_str="assignsub";//-=
            break;
        case ASSIGNDIV:
            op_str="assigndiv";///=
            break;
        case ASSIGNSTAR:
            op_str="assignstar";// *=
            break;
    }
    fprintf(yyout, "%*cBinaryExpr\top: %s\t\n", level, ' ', op_str.c_str());
    expr1->output(level + 4); 
    expr2->output(level + 4);
}

int BinaryExpr::getValue()
{
    int result=0;
    switch(op)
    {
        case ADD:
            if(expr2)
            {
                //result=dynamic_cast<IdentifierSymbolEntry*>(expr1->getentry())->getValue()+dynamic_cast<IdentifierSymbolEntry*>(expr2->getentry())->getValue();
                result = expr1->getValue() + expr2->getValue();
            }
            break;
        case SUB:
            result = expr1->getValue() - expr2->getValue();
            break;
        case LESS:
            if(expr2)
            {
                result = expr1->getValue() < expr2->getValue();}
            break;
        case MUL:
            if(expr2)
            {
                result = expr1->getValue() * expr2->getValue();
            }
            break;
        case DIV:
        if(expr2->getValue()!=0)
            {
                result =(int) (expr1->getValue() / expr2->getValue());
            }
            break;
        case GREATER:
        if(expr2)
            {result = expr1->getValue() > expr2->getValue();}
            break;
        case GEQUAL:
        if(expr2)
            {result = expr1->getValue() >= expr2->getValue();}
            break;
        case LEQUAL:
        if(expr2)
            {result = expr1->getValue()<= expr2->getValue();}
            break;
        case EQUAL:
        if(expr2)
            {result = expr1->getValue()==expr2->getValue();}
            break;
        case NOTEQUAL:
        if(expr2)
            {result = expr1->getValue()!=expr2->getValue();}
            break;//!=
        case MOD:
        if(expr2->getValue()!=0)
            {
                result =(int) (expr1->getValue() % expr2->getValue());
            }
            break;//%
        case MLEFT:
        if(expr2)
            {result = expr1->getValue() << expr2->getValue();}
            break;
        case MRIGHT:
        if(expr2)
            {result = (expr1->getValue()) >> (expr2->getValue());}
            break;
        case ANDAND:
        if(expr2)
            {result = expr1->getValue() && expr2->getValue();}
            break;
        case OROR:
        if(expr2)
            {result = expr1->getValue() || expr2->getValue();}
            break;
    }
    return result;
}

void BinaryExpr::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    //判断两个类型是否相同，如果相同，设置结点类型为该类型，如果不相同输出错误信息。
    //获取两个表达式的类型
    Type *type1 = expr1 -> getSymPtr() -> getType();
    Type *type2 = expr2 -> getSymPtr() -> getType();
    if(type1 != type2){
        fprintf(stderr, "type %s and %s mismatch",
                type1 -> toStr().c_str(), type2 -> toStr().c_str());
        exit(EXIT_FAILURE);
    }
    //否则类型为真
    fprintf(yyout, ";\tBinaryExpr TypeCheck CORRECT!\n");
    symbolEntry -> setType(type1);
    expr1 -> typeCheck();
    expr2 -> typeCheck();
}

OneOpExpr::OneOpExpr(SymbolEntry *se, int op, ExprNode* expr): ExprNode(se), op(op), expr(expr)
{
    
}

void OneOpExpr::typeCheck(Node* fromnode=nullptr)
{
    Type *type = expr -> getSymPtr() -> getType();
    if(type -> isVoid()){
        fprintf(stderr, "type can't be void");
        exit(EXIT_FAILURE);
    }
    symbolEntry -> setType(type);
    expr -> typeCheck();
}

void OneOpExpr::genCode()
{
    
}

int OneOpExpr::getValue()
{
    int result;
    switch (op) 
    {
        case TILDE:
            result = ! (expr->getValue());
            break;
        case SUB:
            result = - (expr->getValue());
            break;
    }
    return result;
}

void OneOpExpr::output(int level) 
{
    std::string op_str;
    switch (op) 
    {
        case TILDE:
            op_str = "not";
            break;
        case SUB:
            op_str = "minus";
            break;
    }
    fprintf(yyout, "%*cOneOpExpr\top: %s\t\n", level, ' ', op_str.c_str());
    expr->output(level + 4);
}

void Constant::genCode()
{
    // we don't need to generate code.
}

void Constant::output(int level)
{
    std::string type, value;
    type = symbolEntry->getType()->toStr();
    value = symbolEntry->toStr();
    fprintf(yyout, "%*cIntegerLiteral\tvalue: %s\ttype: %s\n", level, ' ',
            value.c_str(), type.c_str());
}

int Constant::getValue()
{
    return ((ConstantSymbolEntry*)symbolEntry)->getValue();
}

void Constant::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    //常数无需类型检查吧
}

void Id::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getAddr();
    new LoadInstruction(dst, addr, bb);
}

void Id::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    //id无需类型检查吧
}

int Id::getValue()
{

}

Type* Id::getType()
{

}

void Id::output(int level)
{
    std::string name, type;
    int scope;
    name = symbolEntry->toStr();
    type = symbolEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getScope();
    int value;
    value = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getValue();
    fprintf(yyout, "%*cId\tname: %s\tscope: %d\ttype: %s\tvalue:%d\n", level, ' ',
        name.c_str(), scope, type.c_str(),value);
}

void CompoundStmt::output(int level)
{
    fprintf(yyout, "%*cCompoundStmt\n", level, ' ');
    if(stmt)
        stmt->output(level + 4);
}

void CompoundStmt::genCode()
{
    // Todo
}

void CompoundStmt::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    if(this->stmt!=nullptr)
    {
        //检查语句。
        this->stmt->typeCheck();
    }
}

void SeqNode::output(int level)
{
    fprintf(yyout, "%*cSequence\n", level, ' ');
    stmt1->output(level + 4);
    stmt2->output(level + 4);
}

void SeqNode::genCode()
{
    // Todo
}

void SeqNode::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    this->stmt1->typeCheck();
    this->stmt2->typeCheck();
}

void DeclStmt::genCode()
{
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    if(se->isGlobal())
    {
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        se->setAddr(addr);
    }
    else if(se->isLocal())
    {
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se);                   // allocate space for local id in function stack.
        entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
        se->setAddr(addr);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.
    }
}

void DeclStmt::output(int level)
{
    id->output(level + 4);
}

void DeclStmt::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    //常量变量声明语句，没有可以类型检查的吧？
}

void ConstDef::output(int level)
{
    fprintf(yyout, "%*cConstDef\n", level, ' ');
    id->output(level + 4);//输出id
    //可能有很多个。
    if(this->getnext())
    {
        this->getnext()->output(level);
    }
}

void ConstDef::typeCheck(Node* fromnode=nullptr)
{
    //常量定义中没有需要检查的东西
}

void ConstDef::genCode()
{

}

void VarDef::output(int level)
{
    fprintf(yyout, "%*cVarDef\n", level, ' ');
    id->output(level + 4);//输出id
    //可能有很多个。
    if(this->getnext())
    {
        this->getnext()->output(level);
    }
}

void VarDef::typeCheck(Node* fromnode=nullptr)
{

}

void VarDef::genCode()
{

}

void IfStmt::genCode()
{
    Function *func;
    BasicBlock *then_bb, *end_bb;
    //得到后续生成的指令要插入的基本块 bb
    func = builder->getInsertBB()->getParent();
    //{}中为then基本块内容
    then_bb = new BasicBlock(func);
    //}结束时候的基本块
    end_bb = new BasicBlock(func);
    //生成 cond 结点的中间代码
    cond->genCode();
    //cond 为真时将跳转到基本块 then_bb，cond 为假时将跳转到基本块 end_bb
    backPatch(cond->trueList(), then_bb);
    backPatch(cond->falseList(), end_bb);
    //设置插入点为基本块 then_bb
    builder->setInsertBB(then_bb);
    //生成 thenStmt 结点的中间代码
    thenStmt->genCode();
    //因为生成thenStmt 结点中间代码的过程中可能改变指令的插入点，因此更新
    then_bb = builder->getInsertBB();
    //生成无条件跳转指令跳转到 end_bb。最后设置后续指令的插入点为 end_bb。
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(end_bb);
}

void IfStmt::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    this->cond->typeCheck();
    this->thenStmt->typeCheck();
}

void IfStmt::output(int level)
{
    fprintf(yyout, "%*cIfStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
}

void IfElseStmt::genCode()
{
    // Todo
}

void IfElseStmt::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    cond->typeCheck();
    thenStmt->typeCheck();
    elseStmt->typeCheck();
}

void IfElseStmt::output(int level)
{
    fprintf(yyout, "%*cIfElseStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
    elseStmt->output(level + 4);
}

//while语句块增加
void WhileStmt::output(int level)
{
    fprintf(yyout, "%*cWhileStmt\n", level, ' ');
    cond->output(level + 4);
    stmt->output(level + 4);
}

void WhileStmt::typeCheck(Node* fromnode=nullptr)
{

}

void WhileStmt::genCode()
{

}

//do while
void DoWhileStmt::output(int level)
{
    fprintf(yyout, "%*cDoWhileStmt\n", level, ' ');
    stmt->output(level + 4);
    cond->output(level + 4);
}

//switch
void SwitchStmt::output(int level)
{
    fprintf(yyout, "%*cWhileStmt\n", level, ' ');
    cond->output(level + 4);
    stmt->output(level + 4);
}

//for
void ForStmt::output(int level)
{
    fprintf(yyout, "%*cForStmt\n", level, ' ');
    cond->output(level + 4);
    stmt->output(level + 4);
}

void ForStmt::typeCheck(Node* fromnode=nullptr)
{

}

void ForStmt::genCode()
{

}

void ReturnStmt::output(int level)
{
    fprintf(yyout, "%*cReturnStmt\n", level, ' ');
    retValue->output(level + 4);
}

void ReturnStmt::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    //操作数和函数声明的返回值类型是否匹配
    fprintf(yyout, ";\tReturn Statement Type Check :\n");
    //可以这样写吗……
    if(fromnode!=nullptr)//说明是函数里面的return语句
    {
        FunctionDef * fromfunc=(FunctionDef * )fromnode;
        Type * istype=fromfunc->getEntry()->getType();
        //函数为void类型，但retvalue不为空
        if(retValue!=nullptr&&istype->isVoid())
        {
            fprintf(stderr,"void类型函数携带返回值");
            exit(EXIT_FAILURE);
        }
        //函数为int类型，但没有返回值
        else if(retValue==nullptr&&(!istype->isVoid()))
        {
            fprintf(stderr,"非void类型函数未携带返回值");
            exit(EXIT_FAILURE);
        }
    }
    
}

void ReturnStmt::genCode()
{
    // Todo
}

//重写assignstmt，修改标识符
AssignStmt::AssignStmt(ExprNode *lval, ExprNode *expr) : lval(lval), expr(expr)
{
    int value=expr->getValue();
    //value = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getValue();
    dynamic_cast<IdentifierSymbolEntry*>(lval->getentry())->setValue(value);

}

void AssignStmt::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    expr->genCode();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(lval->getSymPtr())->getAddr();
    Operand *src = expr->getOperand();
    /***
     * We haven't implemented array yet, the lval can only be ID. So we just store the result of the `expr` to the addr of the id.
     * If you want to implement array, you have to caculate the address first and then store the result into it.
     */
    new StoreInstruction(addr, src, bb);
}

void AssignStmt::output(int level)
{
    fprintf(yyout, "%*cAssignStmt\n", level, ' ');
    lval->output(level + 4);
    expr->output(level + 4);
}

void AssignStmt::typeCheck(Node* fromnode=nullptr)
{
    // Todo
}

void SingleFuncParamNode::output(int level)
{
    fprintf(yyout, "%*cSingleFuncFormalParam\n", level, ' ');
    id->output(level+4);
}

void SingleFuncParamNode::typeCheck(Node* fromnode=nullptr)
{

}

void SingleFuncParamNode::genCode()
{

}

void FuncDefParamsNode::addNext(Id* next)
{
    paramsList.push_back(next);
}

void FuncDefParamsNode::typeCheck(Node* fromnode=nullptr)
{

}

void FuncDefParamsNode::genCode()
{

}

std::vector<Type*> FuncDefParamsNode::getParamsType()
{
    std::vector<Type*> typeArray;
    for(auto param : paramsList)
    {
        typeArray.push_back(param->getType());
    }
    return typeArray;
}

void FuncDefParamsNode::output(int level)
{
    fprintf(yyout, "%*cFuncDefParamsNode\n", level, ' ');
    for(auto param : paramsList){
        param->output(level+4);
    }
}

void FunctionDef::output(int level)
{
    std::string name, type;
    name = se->toStr();
    type = se->getType()->toStr();
    fprintf(yyout, "%*cFunctionDefine function name: %s, type: %s\n", level, ' ', 
            name.c_str(), type.c_str());
    if(params!=nullptr){
        params->output(level+4);
    }
    else{
        fprintf(yyout, "%*cFuncDefParamsNode NULL\n", level+4, ' ');
    }
    stmt->output(level + 4);
}

//函数定义的类型检查
void FunctionDef::typeCheck(Node* fromnode=nullptr)
{
    // Todo
    fprintf(yyout, ";\tFunctionDef %s typecheck:\n", se->toStr().c_str());
    //
}

void FunctionDef::genCode()
{
    Unit *unit = builder->getUnit();
    Function *func = new Function(unit, se);
    BasicBlock *entry = func->getEntry();
    // set the insert point to the entry basicblock of this function.
    builder->setInsertBB(entry);

    stmt->genCode();

    /**
     * Construct control flow graph. You need do set successors and predecessors for each basic block.
     * Todo
    */
   
}

void FuncParamsNode::addNext(ExprNode* next)
{
    paramsList.push_back(next);
}

void FuncParamsNode::typeCheck(Node* fromnode=nullptr)
{

}

void FuncParamsNode::genCode()
{

}

void FuncParamsNode::output(int level)
{
    fprintf(yyout, "%*cFuncParamsNode\n", level, ' ');
    for(auto param : paramsList){
        param->output(level+4);
    }
}

void FuncCallNode::output(int level)
{
    std::string name, type;
    int scope;
    SymbolEntry* funcEntry = funcId->getSymbolEntry();
    name = funcEntry->toStr();
    type = funcEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(funcEntry)->getScope();
    fprintf(yyout, "%*cFuncCallNode\tfuncName: %s\t funcType: %s\tscope: %d\n", 
            level, ' ', name.c_str(), type.c_str(), scope);
    if(params!=nullptr){
        params->output(level+4);
    }
    else{
        fprintf(yyout, "%*cFuncParamsNode NULL\n", level+4, ' ');
    }
}

void FuncCallNode::typeCheck(Node* fromnode=nullptr)
{

}

void FuncCallNode::genCode()
{

}

void ExprStmtNode::addNext(ExprNode* next)
{
    exprList.push_back(next);
}

void ExprStmtNode::output(int level)
{
    fprintf(yyout, "%*cExprStmtNode\n", level, ' ');
    for(auto expr : exprList)
    {
        expr->output(level+4);
    }
}

void ExprStmtNode::typeCheck(Node* fromnode=nullptr)
{

}

void ExprStmtNode::genCode()
{
    for(auto expr : exprList)
    {
        expr->genCode();
    }
}

void EmptyStmt::output(int level)
{
    fprintf(yyout, "%*cEmptyStmt\n", level, ' ');
}

void EmptyStmt::typeCheck(Node* fromnode=nullptr)
{

}

void EmptyStmt::genCode()
{
    //空白语句无需编写汇编代码
}

void Ast::typeCheck(Node* fromnode=nullptr)
{
    if(root != nullptr)
        root->typeCheck();
}

void Ast::genCode(Unit *unit)
{
    IRBuilder *builder = new IRBuilder(unit);
    Node::setIRBuilder(builder);
    root->genCode();
}

void Ast::output()
{
    fprintf(yyout, "program\n");
    if(root != nullptr)
        root->output(4);
}
